/*Шестакова Ксения, Б05-126
https://codeforces.com/group/PVbQ8eK2T4/contest/357142/submission/138781276

Реализуйте AVL-дерево. Решения с использованием других структур засчитываться не будут.

Входные данные
Входной файл содержит описание операций с деревом. Операций не больше 105.

В каждой строке находится одна из следующих операций:

insert x — добавить в дерево ключ x. Если ключ x есть в дереве, то ничего делать не надо.
delete x — удалить из дерева ключ x. Если ключа x в дереве нет, то ничего делать не надо.
exists x — если ключ x есть в дереве, вывести «true», иначе «false»
next x — минимальный элемент в дереве, больший x, или «none», если такого нет.
prev x — максимальный элемент в дереве, меньший x, или «none», если такого нет.*/

#include <iostream>
#include <string>
struct Node{
    int key;
    Node* left;
    Node* right;
    int height;
    int balance();
    Node(int key_value);
    void fix_height();
};
Node::Node(int key_value) {
    key=key_value;
    left= nullptr;
    right= nullptr;
    height=1; //считаем высоту вместе с самой вершиной
}

int Node::balance() {
    int right_height=0;
    int left_height=0;
    if (right!= nullptr) right_height=right->height;
    if (left!= nullptr) left_height=left->height;
    int res=(right_height)-(left_height);
    return res;
}

void Node::fix_height() {
    int left_height=0;
    int right_height=0;
    if ( left!= nullptr) left_height=left->height;
    if ( right!= nullptr) right_height=right->height;
    height=std::max(left_height, right_height)+1;
}
Node* left_rotation( Node* current){//поворот, в результате которого правый сын станет на место текущего узла
    Node* new_node=current->right; //новый текущий
    current->right=new_node->left;
    new_node->left=current;
    current->fix_height();
    new_node->fix_height();

    return new_node;
}

Node* right_rotation( Node* current){//поворот, в результате которого левый сын станет на место текущего узла
    Node* new_node=current->left; //новый текущий
    current->left=new_node->right;
    new_node->right=current;
    current->fix_height();
    new_node->fix_height();

    return new_node;
}

Node* fix_balance( Node* current){
    if (current==nullptr) return nullptr;
    current->fix_height();
    if (current->balance()==2){//это значит, чт-о правое поддерево перевешивает и надо крутить влево
        if ( ((current->right)->balance())<0) current->right= right_rotation(current->right);
        return left_rotation(current);
    }
    if (current->balance()==-2){//это значит, что левое поддерево перевешивает и надо крутить вправо
        if ( ((current->left)->balance())>0) current->left= left_rotation(current->left);
        return right_rotation(current);
    }
    return current; //случай, когда узел и так сбалансированный
}
bool exists ( Node* root, int x){
    if (root== nullptr) return false;
    if ( root->key==x) return true;
    if ( root->key>=x) return exists( root->left, x);
    return exists(root->right, x);
}
Node* next ( Node* root, int x){
    if (root== nullptr) return nullptr;
    if (root->key<=x) return next(root->right, x);
    Node* left_next=next(root->left, x);
    if (left_next!= nullptr) return left_next;
    return root;
}

Node* prev ( Node* root, int x){
    if (root== nullptr) return nullptr;
    if (root->key>=x) return prev(root->left, x);
    Node* right_prev=prev(root->right, x);
    if (right_prev!= nullptr) return right_prev;
    return root;
}
Node*  insert ( Node* root, int key_value){ //вставляем в дерево с корнем root число key_value
    if ( root== nullptr)  return new Node(key_value);
    if ( root->key > key_value) root->left=insert(root->left, key_value);
    else root->right=insert(root->right, key_value);
    return fix_balance(root);
}
Node* getMin( Node* root){//находим указатель на вершину, хранящую наименьший элемент
    if (root==nullptr) return nullptr;
    if (root->left== nullptr) return root;
    return getMin(root->left);
}
Node* erase_min( Node* root){
    if (root== nullptr) return nullptr;
    if (root->left!= nullptr) {
        root->left= erase_min(root->left);
        return fix_balance(root);
    }
    return root->right;
}
Node* erase(Node* root, Node* global_root, int x){//возвращает новый корень, как и все предыдущие
    if (root== nullptr) return nullptr;
    if (root->key<x) {
        root->right=erase( root->right, global_root, x);
        return fix_balance(root);
    }
    if (root->key>x) {
        root->left=erase( root->left, global_root, x);
        return fix_balance(root);
    }
    //root->key==x
    if (root->right== nullptr) {
        root=root->left;
        return fix_balance(root);
    }
    Node* min= getMin(root->right); //наименьший элемент в правом поддереве, который мы хотим поставить на место нашего
    root->key=min->key;
    root->right= erase_min(root->right);
    return fix_balance(root);
}
void show (Node* root){
    if (root== nullptr) return;
    show( root->left);

    std::cout<< (root->key)<<" ";
    show( root->right);

}
void clear (Node* root){
    if (root== nullptr) return;
    clear( root->left);
    clear( root->right);
    delete root;
}
class AVL{
    Node* root;
public:
    bool _exists(int x){
        return exists(root, x);
    }
    void _insert(int x){
        if (!exists(root, x))  root=insert(root, x);
    }
    void _delete(int x){
        if ( exists(root, x))  root=erase(root, root, x);
    }
    Node* _prev(int x){
        return prev(root, x);
    }
    Node* _next(int x) {
        return next(root, x);
    }
    AVL(){
        root=nullptr;
    }
    ~AVL(){
        clear(root);
    }

};


int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    AVL myAVL;
    int x;
    std::string asking;

    while (std::cin>>asking){
        if ( asking=="insert"){
            std::cin>>x;
            myAVL._insert(x);
        }
        if (asking=="delete"){
            std::cin>>x;
            myAVL._delete(x);
        }
        if (asking=="exists"){
            std::cin>>x;
            if (myAVL._exists(x)) std::cout<<"true"<<'\n';
            else std::cout<<"false"<<'\n';
        }
        if (asking=="prev"){
            std::cin>>x;
            Node* current_prev=myAVL._prev(x);
            if ( current_prev== nullptr) std::cout<<"none";
            else std::cout<<current_prev->key;
            std::cout<<'\n';
        }
        if (asking=="next"){
            std::cin>>x;
            Node* current_next=myAVL._next(x);
            if ( current_next== nullptr) std::cout<<"none";
            else std::cout<<current_next->key;
            std::cout<<'\n';
        }
    }
    myAVL.~AVL();
    return 0;
}
