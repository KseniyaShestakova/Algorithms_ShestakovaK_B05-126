/*
Шестакова Ксения, Б05-126
https://codeforces.com/group/PVbQ8eK2T4/contest/357142/submission/138131956

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить k-й максимум.
Реализовано с помощью АВЛ-дерева.
Входные данные
Первая строка входного файла содержит натуральное число n — количество команд (n≤100000). Последующие n строк содержат по одной команде каждая. 
Команда записывается в виде двух чисел ci и ki — тип и аргумент команды соответственно (|ki|≤109).

Поддерживаемые команды:

+1 (или просто 1): Добавить элемент с ключом ki.
   0: Найти и вывести ki-й максимум.
−1: Удалить элемент с ключом ki.
Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными ключами или удалять несуществующие элементы. 
Также гарантируется, что при запросе ki-го максимума, он существует.
*/
#include <iostream>
#include<string>
struct Node{
    int key;
    int subtree_size;
    Node* left;
    Node* right;
    int height;
    int balance();
    Node(int key_value);
    void fix_height();
};
Node::Node(int key_value) {
    key=key_value;
    left= nullptr;
    right= nullptr;
    height=1; //считаем высоту вместе с самой вершиной
    subtree_size=1; //считаем вместе с вершиной
}

int Node::balance() {
    int right_height=0;
    int left_height=0;
    if (right!= nullptr) right_height=right->height;
    if (left!= nullptr) left_height=left->height;
    int res=(right_height)-(left_height);
    return res;
}

void Node::fix_height() {
    int left_height=0;
    int right_height=0;
    if ( left!= nullptr) left_height=left->height;
    if ( right!= nullptr) right_height=right->height;
    height=std::max(left_height, right_height)+1;//height fixed

    int left_size=0;
    int right_size=0;
    if ( left!= nullptr) left_size=left->subtree_size;
    if ( right!= nullptr) right_size=right->subtree_size;
    subtree_size=left_size+ right_size+1;//subtree size fixed
}

Node* left_rotation( Node* current){//поворот, в результате которого правый сын станет на место текущего узла
    Node* new_node=current->right; //новый текущий
    current->right=new_node->left;
    new_node->left=current;
    current->fix_height();
    new_node->fix_height();

    return new_node;
}

Node* right_rotation( Node* current){//поворот, в результате которого левый сын станет на место текущего узла
    Node* new_node=current->left; //новый текущий
    current->left=new_node->right;
    new_node->right=current;
    current->fix_height();
    new_node->fix_height();

    return new_node;
}

Node* fix_balance( Node* current){
    if (current==nullptr) return nullptr;
    current->fix_height();
    if (current->balance()==2){//это значит, что правое поддерево перевешивает и надо крутить влево
        if ( ((current->right)->balance())<0) current->right= right_rotation(current->right);
        return left_rotation(current);
    }
    if (current->balance()==-2){//это значит, что левое поддерево перевешивает и надо крутить вправо
        if ( ((current->left)->balance())>0) current->left= left_rotation(current->left);
        return right_rotation(current);
    }
    return current; //случай, когда узел и так сбалансированный
}
bool exists ( Node* root, int x){
    if (root== nullptr) return false;
    if ( root->key==x) return true;
    if ( root->key>=x) return exists( root->left, x);
    return exists(root->right, x);
}
Node* next ( Node* root, int x){
    if (root== nullptr) return nullptr;
    if (root->key<=x) return next(root->right, x);
    Node* left_next=next(root->left, x);
    if (left_next!= nullptr) return left_next;
    return root;
}

Node* prev ( Node* root, int x){
    if (root== nullptr) return nullptr;
    if (root->key>=x) return prev(root->left, x);
    Node* right_prev=prev(root->right, x);
    if (right_prev!= nullptr) return right_prev;
    return root;
}
Node*  insert ( Node* root, int key_value){ //вставляем в дерево с корнем root число key_value
    if ( root== nullptr)  return new Node(key_value);
    if ( root->key > key_value) root->left=insert(root->left, key_value);
    else root->right=insert(root->right, key_value);
    return fix_balance(root);
}
Node* getMin( Node* root){//находим указатель на вершину, хранящую наименьший элемент
    if (root==nullptr) return nullptr;
    if (root->left== nullptr) return root;
    return getMin(root->left);
}
Node* erase_min( Node* root){
    if (root== nullptr) return nullptr;
    if (root->left!= nullptr) {
        root->left= erase_min(root->left);
        return fix_balance(root);
    }
    return root->right;
}
Node* erase(Node* root, Node* global_root, int x){//возвращает новый корень, как и все предыдущие
    if (root== nullptr) return nullptr;
    if (root->key<x) {
        root->right=erase( root->right, global_root, x);
        return fix_balance(root);
    }
    if (root->key>x) {
        root->left=erase( root->left, global_root, x);
        return fix_balance(root);
    }
    //root->key==x
    if (root->right== nullptr) {
        root=root->left;
        return fix_balance(root);
    }
    Node* min= getMin(root->right); //наименьший элемент в правом поддереве, который мы хотим поставить на место нашего
    root->key=min->key;
    root->right= erase_min(root->right);
    return fix_balance(root);
}
void show (Node* root){
    if (root== nullptr) return;
    show( root->left);

    std::cout<< (root->key)<<" ";
    show( root->right);

}
void clear (Node* root){
    if (root== nullptr) return;
    clear( root->left);
    clear( root->right);
    delete root;
}
int sub_size(Node* node){
    if (node== nullptr) return 0;
    return node->subtree_size;
}
int kth_max(Node* root, int k){
    if (sub_size(root->right)>=k) return kth_max(root->right, k);//есть хотя бы k чисел больше корня, ищем среди них
    if (sub_size(root->right)==k-1) return root->key;
    return kth_max(root->left, k-1- sub_size(root->right));
}
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    Node* root= nullptr;
    int n;
    std::cin>>n;
    std::string asking;
    int k;
    for (int i=0; i<n; i++){
        std::cin>>asking;
        std::cin>>k;
        if (asking=="1" || asking=="+1"){
            root=insert(root, k);
            continue;
        }
        if (asking=="-1"){
            root=erase(root, root, k);
            continue;
        }
        if (asking=="0"){
            std::cout<<kth_max(root, k)<<'\n';
        }
    }
    clear(root);
    return 0;
}
