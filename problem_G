/*Шестакова Ксения, Б05-126
До конца света осталось не так много дней, но Третий всадник Апокалипсиса Голод так и не смог понять, какие города стоит наказывать за прегрешения, а какие нет. 
Тогда он решил потренироваться на одной небольшой стране.

Эта страна представляет собой клетчатый прямоугольник размера n×m, в котором каждая клетка — отдельный город. Голод может либо наслать голод на город, либо пощадить его.
При этом есть города, в которых еды хватит и до следующего конца света, и Голод не в силах заставить их голодать, а есть те, в которых еды никогда и не было, и им в любом случае придется голодать.

Страшный Суд Голода должен быть ещё и справедлив, а это значит, что в любом квадрате размера 2×2 должно быть поровну голодающих и сытых городов.
Теперь Голод хочет узнать количество различных вариантов распределения городов этой страны на голодающие и сытые.

Решение:  dp[i][k] - для маски i хранит количество хороших (таких, что до них можно дополнить таблицу распределения голодания по городам,
которая приходит на вход. Таблица состоит из 0 и 1, + на входе трактуется как 1, - как 0) таблиц n* k, на заканчивающихся
на строку, в которой 1 стоит на те хже позициях, на которых стоит 1 в двоичной записи числа i. Переход осуществляется домножением на матрицу, предпосчитанную в начале +
проверкой того, может ли хорошая таблица заканчиваться на mask для каждого значения mask (класс матриц не написан, т.к. умножения лучше, чем за линейное время,
здесь использовать нельзя). Начальные значения и порядок пересчета описаны в функции number_of_partitions. 
Асимптотика: O(n * m)
*/
#include <iostream>
#include <vector>
#include <string>

bool is_good(int n, int num){
    int prev_digit = num & 1;
    while (n - 1){
        num = num >> 1;
        --n;
        if (prev_digit == (num & 1)) return false;
        prev_digit = num & 1;
    }
    return true;
}

long long number_of_partitions(std::vector<int>& necessary1, std::vector<int>& necessary0, int n, int m) {
    long long base = 1e9 + 7;
    std::vector<int> first_option(1 << n);
    std::vector<int> second_option(1 << n);
    for (int i = 0; i < (1 << n); ++i) {
    //для маски считаем те 1 или 2 строки, которые можно дописать к таблице, заканчивающейся на эту маску, чтобы не испортить условие о том,
    //что в квадрате 2*2 поровну клеток белого и черного цветов
        first_option[i] = ((1 << n) - 1) ^ i;
        if (is_good(n, i)) second_option[i] = i;
        else second_option[i] = -1;
    }
    std::vector<long long> dp(1 << n); //для каждой маски хранит количество хороших таблиц, на нее заканчивающихся
    for (int i = 0; i < (1 << n); ++i) {
        dp[i] = 0;
        if ((i & necessary1[0]) == necessary1[0] && (i & necessary0[0]) == 0){
            dp[i] = 1;
        }
         //момент времени 0, т.е начальные значения
    }
    std::vector<long long> prev_dp(1 << n);
    for (int i = 1; i < m; ++i) {
        prev_dp = dp;
        for (int j = 0; j < (1 << n); ++j) {
            dp[j] = 0;
            if ((j & necessary1[i]) == necessary1[i] && (j & necessary0[i]) == 0) {
                dp[j] = prev_dp[first_option[j]];
                dp[j] %= base;
                if (second_option[j] != -1) {
                    dp[j] += prev_dp[second_option[j]];
                    dp[j] %= base;
                }
            }
        }
    }
    long long answer = 0;
    for (int i = 0; i < (1 << n); ++i) {
        answer += dp[i];
        answer %= base;
    }
    return answer;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int n, m;
    std::cin >> n >> m;
    std::vector<int> necessary1 (m);
    std::vector<int> necessary0 (m);
    std::string asking;
    for (int i = 0; i < n; ++i){
        std::cin >> asking;
        for (int j = 0; j < m; ++j){
            if (asking[j] == '+'){
                necessary1[j] += (1 << i);
            }else{
                if (asking[j] == '-'){
                    necessary0[j] += (1 << i);
                }
            }
        }
    }
    std::cout << number_of_partitions(necessary1, necessary0, n, m);
    return 0;
}
